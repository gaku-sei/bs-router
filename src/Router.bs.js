// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Util$BsRouter = require("./Util.bs.js");
var PatternTrie$BsRouter = require("./PatternTrie.bs.js");

function pathPattern(param) {
  switch (param.tag | 0) {
    case /* End */0 :
        return /* [] */0;
    case /* Match */1 :
        return /* :: */[
                /* Match */[param[0]],
                pathPattern(param[1])
              ];
    case /* Conv */2 :
        return /* :: */[
                /* Capture */0,
                pathPattern(param[1])
              ];
    
  }
}

function parseRoute(fmt, handler, params) {
  var matchTarget = function (_t, f, _s) {
    while(true) {
      var s = _s;
      var t = _t;
      switch (t.tag | 0) {
        case /* End */0 :
            var trailingSlash = t[/* trailingSlash */0];
            if (s) {
              if (s[0] === "" && !(s[1] || trailingSlash !== true)) {
                return Caml_option.some(f);
              } else {
                return ;
              }
            } else if (trailingSlash === false) {
              return Caml_option.some(f);
            } else {
              return ;
            }
        case /* Match */1 :
            if (s && t[0] === s[0]) {
              _s = s[1];
              _t = t[1];
              continue ;
            } else {
              return ;
            }
        case /* Conv */2 :
            if (s) {
              var xs = s[1];
              var fmt = t[1];
              var __x = Curry._1(t[0].from, s[0]);
              return Belt_Option.flatMap(__x, (function(fmt,xs){
                        return function (x$prime) {
                          return matchTarget(fmt, Curry._1(f, x$prime), xs);
                        }
                        }(fmt,xs)));
            } else {
              return ;
            }
        
      }
    };
  };
  return matchTarget(fmt, handler, params);
}

function make(routes) {
  var __x = Belt_List.reverse(routes);
  return Belt_List.reduce(__x, PatternTrie$BsRouter.empty, (function (routes, route) {
                return PatternTrie$BsRouter.add(pathPattern(route[0]), route, routes);
              }));
}

function match$prime(target) {
  var partial_arg = Util$BsRouter.splitPath(target);
  return (function (param) {
      var target = partial_arg;
      var router = param;
      var _param = PatternTrie$BsRouter.feedParams(router, target);
      while(true) {
        var param$1 = _param;
        if (param$1) {
          var match = param$1[0];
          var some = parseRoute(match[0], match[1], target);
          if (some !== undefined) {
            return some;
          } else {
            _param = param$1[1];
            continue ;
          }
        } else {
          return ;
        }
      };
    });
}

exports.make = make;
exports.match$prime = match$prime;
/* No side effect */
